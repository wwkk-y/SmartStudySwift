- rms：接口层-生产者
- rms-service：业务层-消费者
## 场景
- 用户刷题练习可以获取积分
- 可以用现金兑换积分
- 积分可以兑换奖品
- 奖品由维护者和教师提供
## 目标
- 奖品上架：需要审核机制，避免不合规产品
- 下单：考虑到奖品数量有限，先到先得，所以下单需要支持高并发操作。
	- 保证高并发场景下的库存安全性
	- 30分钟内没有支付订单就自动取消订单
## 方案

### 数据库
- 用户积分表
- 奖品表
- 订单表
## 审核机制
- 上传奖品时状态：待审核
- 审核完成后才上架
- 上架后可以下架
通过奖品表的两个字段`publish_state` 和`verify_status`实现
## 下单流程
### 如何支持高并发思路
- 本质上是解决如何在短时间内处理大量请求的问题
- 思路1 -> 简单直接，缩短请求处理时间 -> 请求过滤|性能优化|异步处理|IO优化
- 思路2 -> 加机器，一台机器处理不了就加机器 -> 集群|流量分发|MQ添加消费者
- 思路3 -> 应对突发的大量请求，延后处理 -> MQ削峰，动态修改消费者数量
### 实现方案
![[Pasted image 20241123162251.png]]
#### 下单接口
- redis.setNx 看用户兑换这个奖品没有，一个奖品只能兑换一次
- redis里面存商品的库存，通过定时任务或者管理员手动同步数据库库存到redis
- redis.decrement做库存预扣减
- 库存还够就给mq发下单消息
一共就4步，每一步都很快
这个场景mq需要保证不能重复消费和不能消息丢失，这里主要基于mysql实现：
- 解决消息丢失：WAL（先写日志）
	- 消费者发消息时往mysql里写一条日志，这里涉及数据库操作，所以在RocketMQ发消息异步回调里处理，这样不会占用下单时间；发送成功写成功日志，发送失败写发送失败日志并把消息记录下来人工介入处理
- 解决重复消费：使用mysql唯一索引保证，建一个去重表，开始消费时往mysql去重表里插入一条消息，插入成功说明是第一次消费，插入失败说明消费过了，不处理这条消息
	- 也可以使用redis.setNx优化
		- 优点：更快
		- 缺点：key膨胀
		- 用于处理对性能要求更严格的场景，这里用mysql够用了就没有使用redis
#### 库存安全性
- 目标
	- 保证下单量不超库存
	- 保证下单过程中商品被主动下架时库存不扣减
- redis库存扣减使用increment保证线程安全
- 业务层：
	- 使用MySQL的锁：扣减库存带上条件 `inventory > 0 and 判断 status 是 '没下架'`，看修改成功没，修改没成功说明扣减库存失败，抛出异常
	- 如果想减少MySQL的压力，也使用 redi.setNx锁 + 自旋 实现分布式锁，但是这里的场景mysql完全够用就直接使用的mysql的行锁
### 订单超时自动取消
- 下单时使用RocketMQ发送一个延迟消息30分钟后用来取消订单
- 消费者30分钟后处理时看订单支付没有，如果还没支付就把订单状态改成已取消
## 效果
- 实现了严格的审核机制，有效避免不合规的商品上架
- 积分兑换奖品操作在高并发场景下运行性能良好
	- 使用JMeter压测，对秒杀接口进行压力测试，在6C16G的服务器上，qps达到2k以上，达到压测预期
	- 并且保证了库存的安全性。
- 实现订单超时自动取消
