
## 目标
- 基于SpringSecurity实现基于角色的权限控制RBAC模型
- 可以由主动下线用户 -> redis设置token键
## 方案
- JWT + SpringSecurity
- 数据库结构：
	- um_user 用户
		- um_role_of_user
	- um_role 角色
		- um_permission_of_role
	- um_permission 权限

核心执行流程
- `SecurityFilterChain.filterChain()`：用于配置SecurityFilterChain实例，SpringSecurity的核心配置类，可以SpringSecurity进行路径授权配置、过滤器配置等；
	- 排除白名单`ignoreUrlsConfig.urls`, 在`properties`里配置
	- 允许跨域请求的OPTIONS请求
		- OPTIONS请求即预检请求，可用于检测服务器允许的http方法。
	- 其它所有接口都需要认证
	- 关闭跨站请求防护及不使用session
	- 设置异常时返回结果为通用格式
		 - 无权限访问: `AccessDeniedHandler`
		-  未登录或者`token`失效: `AuthenticationEntryPoint`
		- 登录失败: `AuthenticationFailureHandler`
	- 自定义拦截器JWT过滤器处理：在请求之前执行，解析`token`为用户信息保存到上下文中
		- 根据`token`获取用户名`uername`
		- 看`redis`中有没有`token`, 有的话表示在线
		- `userDetailsService.loadUserByUsername(username)`获取用户详细信息, 包括用户，角色，权限，封装成`UserDetails`返回
			- `UserDetailsService` 和 `UserDetails` 需要自行实现，此处是去数据库里查询对应数据
		- 将用户信息放到请求上下文中表示已登录
## 具体步骤
### 数据库
```sql
create table ums_user  
(  
    id                   bigint not null auto_increment,  
    username             varchar(64) comment '用户名',  
    password             varchar(64) comment '密码',  
    icon                 varchar(500) comment '头像',  
    email                varchar(100) comment '邮箱',  
    nick_name            varchar(200) comment '昵称',  
    note                 varchar(500) comment '备注信息',  
    login_time           datetime comment '最后登录时间',  
    create_time          datetime comment '创建时间',  
    update_time          datetime comment '修改时间',  
    status               int(1) default 1 comment '帐号启用状态：0->禁用；1->启用',  
    primary key (id)  
);  
  
create table ums_role  
(  
    id                   bigint not null auto_increment,  
    name                 varchar(100) comment '名称',  
    description          varchar(500) comment '描述',  
    sort                 int default 0,  
    create_time          datetime comment '创建时间',  
    update_time          datetime comment '修改时间',  
    status               int(1) default 1 comment '启用状态：0->禁用；1->启用',  
    primary key (id)  
);  
  
create table ums_role_of_user  
(  
    id                   bigint not null auto_increment,  
    user_id              bigint,  
    role_id              bigint,  
    primary key (id)  
);  
  
create table ums_permission  
(  
    id                   bigint not null auto_increment,  
    name                 varchar(100) comment '名称',  
    description          varchar(500) comment '描述',  
    sort                 int default 0,  
    create_time          datetime comment '创建时间',  
    update_time          datetime comment '修改时间',  
    status               int(1) default 1 comment '启用状态：0->禁用；1->启用',  
    primary key (id)  
);  
  
create table ums_permission_of_role  
(  
    id                   bigint not null auto_increment,  
    permission_id        bigint,  
    role_id              bigint,  
    primary key (id)  
);
```
### 引入依赖
#### 父模块
- `pom.xml`
```xml
<properties>
	<jjwt.version>0.9.1</jjwt.version>
	
	<!--常用子模块-->  
	<xxx-security.version>0.0.1-SNAPSHOT</xxx-security.version>
</properties>
```

```xml
<dependencyManagement>
    <dependencies>  
        <!--JWT(Json Web Token)登录支持-->  
        <dependency>  
            <groupId>io.jsonwebtoken</groupId>  
            <artifactId>jjwt</artifactId>  
            <version>${jjwt.version}</version>  
        </dependency> 

		<!--常用子模块-->  
		<dependency>  
		    <groupId>com.xxx</groupId>  
		    <artifactId>xxx-security</artifactId>  
		    <version>${xxx-security.version}</version>  
		</dependency>
    </dependencies>  
</dependencyManagement>
```
#### 新建子模块`xxx-security`
- `pom.xml`
```xml
<dependencies>  
    <dependency>  
        <groupId>com.sss</groupId>  
        <artifactId>sss-common</artifactId>  
    </dependency>  
    <dependency>  
        <groupId>org.springframework.boot</groupId>  
        <artifactId>spring-boot-starter-security</artifactId>  
    </dependency>  
    <dependency>  
        <groupId>io.jsonwebtoken</groupId>  
        <artifactId>jjwt</artifactId>  
    </dependency>  
</dependencies>
```
### security模块
#### 核心配置
```java
import org.springframework.context.annotation.Configuration;  
  
import org.springframework.context.annotation.Bean;  
import org.springframework.http.HttpMethod;  
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;  
import org.springframework.security.config.annotation.web.builders.HttpSecurity;  
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;  
import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;  
import org.springframework.security.config.http.SessionCreationPolicy;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.SecurityFilterChain;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.AuthenticationFailureHandler;  
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;  
  
import javax.annotation.Resource;  
  
  
/**  
 * SpringSecurity相关配置，仅用于配置SecurityFilterChain  
 */@Configuration  
@EnableWebSecurity  
@EnableMethodSecurity(  
        prePostEnabled = true,  
        securedEnabled = true,  
        jsr250Enabled = true  
) // 开启权限注解  
public class SecurityLogicConfig {  
    @Resource  
    private IgnoreUrlsConfig ignoreUrlsConfig; // url白名单  
    @Resource  
    private AccessDeniedHandler accessDeniedHandler; // 权限不足处理器  
    @Resource  
    private AuthenticationEntryPoint authenticationEntryPoint; // token失效处理器  
    @Resource  
    private AuthenticationFailureHandler authenticationFailureHandler; // 登录失败处理器  
    @Resource  
    private JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter; // token处理器  
  
    @Bean  
    SecurityFilterChain filterChain(HttpSecurity httpSecurity) throws Exception {  
        ExpressionUrlAuthorizationConfigurer<HttpSecurity>.ExpressionInterceptUrlRegistry registry = httpSecurity  
                .authorizeRequests();  
  
        //不需要保护的资源路径允许访问  
        for (String url : ignoreUrlsConfig.getUrls()) {  
            registry.antMatchers(url).permitAll();  
        }  
  
        //允许跨域请求的OPTIONS请求  
        registry.antMatchers(HttpMethod.OPTIONS)  
                .permitAll();  
  
        registry  
                //任何请求都需要身份认证  
                .and()  
                .authorizeRequests()  
                .anyRequest()  
                .authenticated()  
                //关闭跨站请求防护及不使用session  
                .and()  
                .csrf()  
                .disable()  
                .sessionManagement()  
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)  
                //自定义权限拒绝处理类  
                .and()  
                .exceptionHandling()  
                .accessDeniedHandler(accessDeniedHandler)  
                .authenticationEntryPoint(authenticationEntryPoint)  
                //自定义登录失败处理器  
                .and()  
                .formLogin()  
                .failureHandler(authenticationFailureHandler)  
                //自定义权限拦截器JWT过滤器  
                .and()  
                .addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);  
  
        return httpSecurity.build();  
    }  
  
}
```
#### 常量配置
```java
// 常量  
public class SecurityConstConfig {  
    public static final String TOKEN_REDIS_PREFIX = "TOKEN_"; // token在redis里面的前缀
    public static final String ROLE_PREFIX = "ROLE_"; // 角色权限前缀  
}
```
#### url白名单类
```java
import lombok.Getter;  
import lombok.Setter;  
import org.springframework.boot.context.properties.ConfigurationProperties;  
  
import java.util.ArrayList;  
import java.util.List;  
  
/**  
 * url白名单  
 */  
@Getter  
@Setter  
@ConfigurationProperties(prefix = "secure.ignored")  
public class IgnoreUrlsConfig {  
    private final List<String> urls = new ArrayList<>();  
}
```
#### Mybatis配置
```java
import org.mybatis.spring.annotation.MapperScan;  
import org.springframework.context.annotation.Configuration;  
  
@Configuration  
@MapperScan("com.xxx.security.mapper")  
public class SecurityMyBatisConfig {  
}
```
#### redis配置
[[05-引入redis相关]]
#### 常见异常处理器
```java
import cn.hutool.json.JSONUtil;  
import org.springframework.security.access.AccessDeniedException;  
import org.springframework.security.core.AuthenticationException;  
import org.springframework.security.web.AuthenticationEntryPoint;  
import org.springframework.security.web.access.AccessDeniedHandler;  
import org.springframework.security.web.authentication.AuthenticationFailureHandler;  
  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
  
  
public class SecurityExceptionHandler implements AuthenticationEntryPoint, AccessDeniedHandler,AuthenticationFailureHandler {  
  
    /**  
     * 自定义无权限访问的返回结果  
     */  
    @Override  
    public void handle(HttpServletRequest request,  
                       HttpServletResponse response,  
                       AccessDeniedException e) throws IOException, ServletException {  
        response.setHeader("Access-Control-Allow-Origin", "*");  
        response.setHeader("Cache-Control","no-cache");  
        response.setCharacterEncoding("UTF-8");  
        response.setContentType("application/json");  
        response.getWriter().println(JSONUtil.parse(RResult.forbidden(e.getMessage())));  
        response.getWriter().flush();  
    }  
  
    /**  
     * 自定义未登录或者token失效时的返回结果  
     */  
    @Override  
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {  
        response.setHeader("Access-Control-Allow-Origin", "*");  
        response.setHeader("Cache-Control","no-cache");  
        response.setCharacterEncoding("UTF-8");  
        response.setContentType("application/json");  
        response.getWriter().println(JSONUtil.parse(RResult.unauthorized(authException.getMessage())));  
        response.getWriter().flush();  
    }  
  
    /**  
     * 认证失败  
     */  
    @Override  
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {  
        response.setHeader("Access-Control-Allow-Origin", "*");  
        response.setHeader("Cache-Control","no-cache");  
        response.setCharacterEncoding("UTF-8");  
        response.setContentType("application/json");  
        response.getWriter().println(JSONUtil.parse(RResult.unauthorized(exception.getMessage())));  
        response.getWriter().flush();  
    }  
}
```
#### JWT过滤器
```java
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.beans.factory.annotation.Value;  
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;  
import org.springframework.security.core.context.SecurityContextHolder;  
import org.springframework.security.core.userdetails.UserDetails;  
import org.springframework.security.core.userdetails.UserDetailsService;  
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;  
import org.springframework.web.filter.OncePerRequestFilter;  
  
import javax.annotation.Resource;  
import javax.servlet.FilterChain;  
import javax.servlet.ServletException;  
import javax.servlet.http.HttpServletRequest;  
import javax.servlet.http.HttpServletResponse;  
import java.io.IOException;  
  
/**  
 * JWT登录授权过滤器  
 */  
public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {  
    private static final Logger LOGGER = LoggerFactory.getLogger(JwtAuthenticationTokenFilter.class);  
    @Autowired  
    private UserDetailsService userDetailsService;  
    @Autowired  
    private JWTUtil jwtUtil;  
    @Value("${jwt.tokenKey}")  
    private String tokenKey;  
    @Value("${jwt.tokenPrefix}")  
    private String tokenPrefix;  
    @Resource  
    private RedisService redisService;  
  
    @Override  
    protected void doFilterInternal(HttpServletRequest request,  
                                    HttpServletResponse response,  
                                    FilterChain chain) throws ServletException, IOException {  
        String authHeader = request.getHeader(tokenKey);  
  
        if (authHeader != null && authHeader.startsWith(tokenPrefix)) {  
            // 去掉前缀，解析 token -> username            String authToken = authHeader.substring(tokenPrefix.length());// The part after "Bearer "  
            String username = jwtUtil.getUserNameFromToken(authToken);  
            LOGGER.info("checking username: {}", username);  
  
            if (redisService.hasKey(SecurityConstConfig.TOKEN_REDIS_PREFIX + authHeader) && // 看过期没有  
                    username != null && SecurityContextHolder.getContext().getAuthentication() == null) {  
                // 放置用户信息及其权限信息到上下文  
  
                // 根据用户名获取用户信息  
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);  
  
                if (jwtUtil.validateToken(authToken, userDetails)) {  
                    UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(  
                            userDetails,  
                            null,                            userDetails.getAuthorities()  
                    );  
                    authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); // 增强认证过程的安全性  
                    LOGGER.info("authenticated user: {}", username);  
                    SecurityContextHolder.getContext().setAuthentication(authentication);  
                }  
            }  
        }  
        chain.doFilter(request, response);  
    }  
}
```
#### 注入常用对象
```java
import org.springframework.context.annotation.Bean;  
import org.springframework.context.annotation.Configuration;  
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;  
import org.springframework.security.crypto.password.PasswordEncoder;  
  
/**  
 * SpringSecurity通用配置  
 * 包括通用Bean、Security通用Bean及动态权限通用Bean  
 */@Configuration  
public class SecurityBeanConfig {  
  
    @Bean  
    public PasswordEncoder passwordEncoder() {  
        return new BCryptPasswordEncoder();  
    }  
  
    @Bean  
    public IgnoreUrlsConfig ignoreUrlsConfig() {  
        return new IgnoreUrlsConfig();  
    }  
  
    @Bean  
    public JWTUtil JWTUtil() {  
        return new JWTUtil();  
    }  
  
    @Bean  
    public SecurityExceptionHandler restfulAccessDeniedHandler() {  
        return new SecurityExceptionHandler();  
    }  
  
    @Bean  
    public JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter() {  
        return new JwtAuthenticationTokenFilter();  
    }  
}
```
#### JWT工具类
```java
import cn.hutool.core.date.DateUtil;  
import cn.hutool.core.util.StrUtil;  
import io.jsonwebtoken.Claims;  
import io.jsonwebtoken.Jwts;  
import io.jsonwebtoken.SignatureAlgorithm;  
import org.slf4j.Logger;  
import org.slf4j.LoggerFactory;  
import org.springframework.beans.factory.annotation.Value;  
import org.springframework.security.core.userdetails.UserDetails;  
  
import java.util.Date;  
import java.util.HashMap;  
import java.util.Map;  
  
/**  
 * JwtToken生成的工具类  
 * JWT token的格式：header.payload.signature  
 * header的格式（算法、token的类型）：  
 * {"alg": "HS512","typ": "JWT"}  
 * payload的格式（用户名、创建时间、生成时间）：  
 * {"sub":"wang","created":1489079981393,"exp":1489684781}  
 * signature的生成算法：  
 * HMACSHA512(base64UrlEncode(header) + "." +base64UrlEncode(payload),secret)  
 */public class JWTUtil {  
    private static final Logger LOGGER = LoggerFactory.getLogger(JWTUtil.class);  
    private static final String CLAIM_KEY_USERNAME = "sub";  
    private static final String CLAIM_KEY_CREATED = "created";  
    @Value("${jwt.secret}")  
    private String secret;  
    @Value("${jwt.expiration}")  
    private Long expiration;  
    @Value("${jwt.tokenPrefix}")  
    public String tokenPrefix; // FIXME  
  
    /**  
     * 根据负责生成JWT的token  
     */    private String generateToken(Map<String, Object> claims) {  
        return Jwts.builder()  
                .setClaims(claims)  
                .setExpiration(generateExpirationDate())  
                .signWith(SignatureAlgorithm.HS512, secret)  
                .compact();  
    }  
  
    /**  
     * 从token中获取JWT中的负载  
     */  
    private Claims getClaimsFromToken(String token) {  
        Claims claims = null;  
        try {  
            claims = Jwts.parser()  
                    .setSigningKey(secret)  
                    .parseClaimsJws(token)  
                    .getBody();  
        } catch (Exception e) {  
            LOGGER.info("JWT格式验证失败:{}", token);  
        }  
        return claims;  
    }  
  
    /**  
     * 生成token的过期时间  
     */  
    private Date generateExpirationDate() {  
        return new Date(System.currentTimeMillis() + expiration * 1000);  
    }  
  
    /**  
     * 从token中获取登录用户名  
     */  
    public String getUserNameFromToken(String token) {  
        String username;  
        try {  
            Claims claims = getClaimsFromToken(token);  
            username = claims.getSubject();  
        } catch (Exception e) {  
            username = null;  
        }  
        return username;  
    }  
  
    /**  
     * 验证token是否还有效  
     *  
     * @param token       客户端传入的token  
     * @param userDetails 从数据库中查询出来的用户信息  
     */  
    public boolean validateToken(String token, UserDetails userDetails) {  
        String username = getUserNameFromToken(token);  
        return username.equals(userDetails.getUsername()) && !isTokenExpired(token);  
    }  
  
    /**  
     * 判断token是否已经失效  
     */  
    private boolean isTokenExpired(String token) {  
        Date expiredDate = getExpiredDateFromToken(token);  
        return expiredDate.before(new Date());  
    }  
  
    /**  
     * 从token中获取过期时间  
     */  
    private Date getExpiredDateFromToken(String token) {  
        Claims claims = getClaimsFromToken(token);  
        return claims.getExpiration();  
    }  
  
    /**  
     * 根据用户信息生成token  
     */    public String generateToken(UserDetails userDetails) {  
        Map<String, Object> claims = new HashMap<>();  
        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());  
        claims.put(CLAIM_KEY_CREATED, new Date());  
        return generateToken(claims);  
    }  
  
    /**  
     * 当原来的token没过期时是可以刷新的  
     *  
     * @param oldToken 带tokenHead的token  
     */    public String refreshHeadToken(String oldToken) {  
        if(StrUtil.isEmpty(oldToken)){  
            return null;  
        }  
        String token = oldToken.substring(tokenPrefix.length());  
        if(StrUtil.isEmpty(token)){  
            return null;  
        }  
        //token校验不通过  
        Claims claims = getClaimsFromToken(token);  
        if(claims==null){  
            return null;  
        }  
        //如果token已经过期，不支持刷新  
        if(isTokenExpired(token)){  
            return null;  
        }  
        //如果token在30分钟之内刚刷新过，返回原token  
        if(tokenRefreshJustBefore(token,30*60)){  
            return token;  
        }else{  
            claims.put(CLAIM_KEY_CREATED, new Date());  
            return generateToken(claims);  
        }  
    }  
  
    /**  
     * 判断token在指定时间内是否刚刚刷新过  
     * @param token 原token  
     * @param time 指定时间（秒）  
     */  
    private boolean tokenRefreshJustBefore(String token, int time) {  
        Claims claims = getClaimsFromToken(token);  
        Date created = claims.get(CLAIM_KEY_CREATED, Date.class);  
        Date refreshDate = new Date();  
        //刷新时间在创建时间的指定时间内  
        if(refreshDate.after(created)&&refreshDate.before(DateUtil.offsetSecond(created,time))){  
            return true;  
        }  
        return false;  
    }  
}
```
----
余下的涉及数据库对接，需要根据实际情况有对应实现，注意映射文件xml需要放到`resource/com/xxx/security/mapper`下，不可以直接放到`resource/mapper`下，因为是给别人用，别人通过`application.yml`文件中配置的`- classpath*:com/**/mapper/*.xml # 不但扫描当前JAR，扫描所有JAR,主要作用：扫描其它地方的mapper`来扫描
#### UserDetailService实现类
```java
import com.sss.security.domain.UserDetailsImpl;  
import com.sss.security.mapper.UmsUserDetailMapper;  
import lombok.extern.slf4j.Slf4j;  
import org.springframework.security.core.userdetails.UserDetails;  
import org.springframework.security.core.userdetails.UserDetailsService;  
import org.springframework.security.core.userdetails.UsernameNotFoundException;  
import org.springframework.stereotype.Service;  
  
import javax.annotation.Resource;  
  
@Service  
@Slf4j  
public class UserDetailServiceImpl implements UserDetailsService {  
    @Resource  
    private UmsUserDetailMapper umsUserDetailMapper;  
  
    @Override  
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {  
        // 根据username获取用户  
        UmsUser umsUser = umsUserDetailMapper.selectUserByUsername(username);  
        if(umsUser == null){  
            throw new UsernameNotFoundException("不存在该用户: " + username);  
        }  
  
        return new UserDetailsImpl(  
                umsUser,  
                umsUserDetailMapper.selectPermissionNameByUserId(umsUser.getId()),  
                umsUserDetailMapper.selectRoleNameByUserId(umsUser.getId())  
        );  
    }  
}
```
#### UserDetail实现类
```java
import com.fasterxml.jackson.annotation.JsonIgnore;    
import com.sss.security.config.SecurityConstConfig;  
import org.springframework.security.core.GrantedAuthority;  
import org.springframework.security.core.authority.SimpleGrantedAuthority;  
import org.springframework.security.core.userdetails.UserDetails;  
  
import java.util.Collection;  
import java.util.List;  
import java.util.stream.Collectors;  
import java.util.stream.Stream;  
  
public class UserDetailsImpl implements UserDetails {  
    private final UmsUser user;  
  
    private final List<String> permissions; // 权限字符串  
  
    @JsonIgnore // 序列化时忽略属性  
    private final List<SimpleGrantedAuthority> authorities;  
  
    public UserDetailsImpl(UmsUser user, List<String> permissions, List<String> roles) {  
        this.user = user;  
        Stream<String> roleStream = roles.stream().map(s -> SecurityConstConfig.ROLE_PREFIX + s); // 角色  
        this.permissions = Stream.concat(roleStream, permissions.stream()).collect(Collectors.toList()); // 权限  
        // 权限 = 角色 + 角色权限  
        authorities = this.permissions.stream().map(SimpleGrantedAuthority::new).collect(Collectors.toList());  
    }  
  
    @Override  
    public Collection<? extends GrantedAuthority> getAuthorities() {  
        return authorities;  
    }  
  
    @Override  
    public String getPassword() {  
        return user.getPassword();  
    }  
  
    @Override  
    public String getUsername() {  
        return user.getUsername();  
    }  
  
    @Override  
    public boolean isAccountNonExpired() {  
        return isEnabled();  
    }  
  
    @Override  
    public boolean isAccountNonLocked() {  
        return isEnabled();  
    }  
  
    @Override  
    public boolean isCredentialsNonExpired() {  
        return isEnabled();  
    }  
  
    @Override  
    public boolean isEnabled() {  
        return user.getStatus() == 1;  
    }  
  
    public UmsUser getUser(){  
        return user;  
    }  
  
    public List<String> getPermissions() {  
        return permissions;  
    }  
}
```
### 需要管理权限的模块
- `pom.xml`
```
<dependency>  
    <groupId>com.sss</groupId>  
    <artifactId>sss-security</artifactId>  
</dependency>
```
- [[04-引入数据库MySQL相关]]：需要扫描Security实现的mapper
- [[05-引入redis相关]]：`security`需要使用到redis
- `application.yml`
```yml
jwt:  
  tokenKey: Authorization #JWT存储的请求头  
  secret: xxx-security-secret #JWT加解密使用的密钥  
  expiration: 604800 #JWT的超期限时间(60*60*24*7)  
  tokenPrefix: 'Bearer '  #JWT负载中拿到开头  
  
secure:  
  ignored:  
    urls: #安全路径白名单  
      - /swagger-ui/  
      - /swagger-resources/**  
      - /**/v2/api-docs  
      - /**/*.html  
      - /**/*.js  
      - /**/*.css  
      - /**/*.png  
      - /**/*.map  
      - /favicon.ico  
      - /druid/**  
      - /actuator/**  
```
- 然后就可以在接口上使用SpringSecurity的权限注解控制权限了
- 获取当前登录的用户
```java
UsernamePasswordAuthenticationToken authentication = (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();  
UserDetailImpl loginUser = (UserDetailImpl) authentication.getPrincipal();
```