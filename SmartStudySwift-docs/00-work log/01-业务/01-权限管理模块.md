
## 目标
- 基于SpringSecurity实现基于角色的权限控制RBAC模型
	- 控制每个角色可以访问的接口范围，还有未登录时可以访问的接口范围
- 效率必须要高，因为每个请求都会执行一遍这个逻辑，不能在这里耗费太长时间，用户体验不好。
- 可靠性必须要高，因为每个请求都会执行一遍这个逻辑，必须要可靠。不能因为某些异常比如redis宕机了就不能用了，导致所有请求都执行不了了
- 可以由主动下线用户
## 方案
- JWT + redis + SpringSecurity
- 数据库结构：
	- um_user 用户
		- um_role_of_user
	- um_role 角色, name使用ROLE_前缀标识可识别为权限，比如ROLE_MANAGER可以使用注解判定
		- um_permission_of_role
	- um_permission 权限
- 每次请求时都会解析token查询用户权限
	- 可以使用redis加快查询速度(优化到5ms以内，数据库查询时间取决于用户量，比如当用户量大于100w时查询时间大于50ms，此时速度优化了到原来的1/10)
	- 但**不能依赖于redis**的可靠性，因为一旦redis不可用时，所有请求都执行不了了
	- 使用redis缓存的代价就是当redis不可用时，有多余的逻辑去处理相关异常，这样耗时比正常查数据库很长(900ms左右，是原来的18倍)，但是考虑一般情况下redis是可用的，
		- 可用时时时间缩短到原来的1/10，小概率不可用时是原来18倍的执行时间，综合考虑下这是可以接受的。
- 主动下线用户
	- 登录时 redis中设置token key，mysql登录日志中添加一条数据。
	- redis 删除token，mysql表中登录状态改成已下线

核心执行流程
- `SecurityFilterChain.filterChain()`：用于配置SecurityFilterChain实例，SpringSecurity的核心配置类，可以SpringSecurity进行路径授权配置、过滤器配置等；
	- 排除白名单`ignoreUrlsConfig.urls`, 在`properties`里配置
	- 允许跨域请求的OPTIONS请求
		- OPTIONS请求即预检请求，可用于检测服务器允许的http方法。
	- 其它所有接口都需要认证
	- 关闭跨站请求防护及不使用session
	- 设置异常时返回结果为通用格式
		 - 无权限访问: `AccessDeniedHandler`
		-  未登录或者`token`失效: `AuthenticationEntryPoint`
		- 登录失败: `AuthenticationFailureHandler`
	- 自定义拦截器JWT过滤器处理：在请求之前执行，解析`token`为用户信息保存到上下文中
		- 根据`token`获取用户名`uername`
		- 看`redis`中有没有`token`, 有的话表示在线
		- `userDetailsService.loadUserByUsername(username)`获取用户详细信息, 包括用户，角色，权限，封装成`UserDetails`返回
			- `UserDetailsService` 和 `UserDetails` 需要自行实现，此处是去数据库里查询对应数据
		- 将用户信息放到请求上下文中表示已登录
## 具体步骤
### 数据库
- 源码见 `xxx-security/sql/create.sql`
### 引入依赖
#### 父模块
- `pom.xml`
```xml
<properties>
	<jjwt.version>0.9.1</jjwt.version>
	
	<!--常用子模块-->  
	<xxx-security.version>0.0.1-SNAPSHOT</xxx-security.version>
</properties>
```

```xml
<dependencyManagement>
    <dependencies>  
        <!--JWT(Json Web Token)登录支持-->  
        <dependency>  
            <groupId>io.jsonwebtoken</groupId>  
            <artifactId>jjwt</artifactId>  
            <version>${jjwt.version}</version>  
        </dependency> 

		<!--常用子模块-->  
		<dependency>  
		    <groupId>com.xxx</groupId>  
		    <artifactId>xxx-security</artifactId>  
		    <version>${xxx-security.version}</version>  
		</dependency>
    </dependencies>  
</dependencyManagement>
```
#### 新建子模块`xxx-security`
- `pom.xml`
```xml
<dependencies>  
    <dependency>  
        <groupId>com.sss</groupId>  
        <artifactId>sss-common</artifactId>  
    </dependency>  
    <dependency>  
        <groupId>org.springframework.boot</groupId>  
        <artifactId>spring-boot-starter-security</artifactId>  
    </dependency>  
    <dependency>  
        <groupId>io.jsonwebtoken</groupId>  
        <artifactId>jjwt</artifactId>  
    </dependency>  
</dependencies>
```
### security模块
- 源码: `xxx-security`
### 需要管理权限的模块
- `pom.xml`
```
<dependency>  
    <groupId>com.sss</groupId>  
    <artifactId>sss-security</artifactId>  
</dependency>
```
- [[04-引入数据库MySQL相关]]：需要扫描Security实现的mapper
- [[05-引入redis相关]]：`security`需要使用到redis
- `application.yml`
```yml
jwt:  
  tokenKey: Authorization #JWT存储的请求头  
  secret: xxx-security-secret #JWT加解密使用的密钥  
  expiration: 604800 #JWT的超期限时间(60*60*24*7)  
  tokenPrefix: 'Bearer '  #JWT负载中拿到开头  
  
secure:  
  ignored:  
    urls: #安全路径白名单  
      - /swagger-ui/  
      - /swagger-resources/**  
      - /**/v2/api-docs  
      - /**/*.html  
      - /**/*.js  
      - /**/*.css  
      - /**/*.png  
      - /**/*.map  
      - /favicon.ico  
      - /druid/**  
      - /actuator/**  
```
- 然后就可以在接口上使用SpringSecurity的权限注解控制权限了
- 获取当前登录的用户
```java
UsernamePasswordAuthenticationToken authentication = (UsernamePasswordAuthenticationToken) SecurityContextHolder.getContext().getAuthentication();  
UserDetailsImpl loginUser = (UserDetailsImpl) authentication.getPrincipal();
```