> [https://github.com/zongzibinbin/MallChat/blob/main/docs/mallchat.sql](https://github.com/zongzibinbin/MallChat/blob/main/docs/mallchat.sql)
# 目标
- 实现基本的聊天功能，支持不同的消息类型，支持已读，未读，撤回。
- 高性能，新消息通知延迟尽可能小，应对大量的消息能高效可靠的处理
# 方案

### 消息积压
- 给群里发消息时，做一个延时1s，如果这段时间内有新消息进来一起发送。因为他是调用前面的这个长连接系统往我们这个RocketMQ里发消息，我就相当于是把多个消息聚合成一条消息发送，这样消费者只需要消费一次来处理这些消息。而且批量处理可以减少网络IO时间
- 对消息执行压缩算法，提高传输速度和缓解消息积压
## QPS
思路，除了前面的，还有异步 + 解耦 RocketMQ，发消息的过程是异步的，发送出错使用长连接系统通知客户端，客户端进行重试。
## 消息表分库分表
FIXME JDBCSharing
- 不可排序
- 不可分页查询
# 具体实现
## 数据库

### 服务端数据库
- 会话表（好友关系） - 成员1id, 成员2id
- 消息记录
- 未读消息
## 会话
### 建立时机
搜索用户 -> 点进会话 -> 发现不存在 -> 创建
- 并发问题: 同时创建 锁住 user_id1 + user_id2
## 消息
### 消息类型
- 一条消息对应一种消息类型, 用字段 `type` 区分, 字段 `content` 存具体内容
```js
// 文本
  {
    "type": "TEXT",
    "content": {
      "text": "123"
    }
  }

// 图片
  {
    "type": "IMAGE",
    "content": {
        "normal": "http://xxx/hello.png",
        "thumbnail": "http://xxx/hello1.png",
        "original": "http://xxx/hello2.png"
    }
  }
```

### 新消息
有两张表会记录新消息: **消息表**和**未读消息表**, 消息表记录所有消息,未读消息表记录未读消息(涉及到已读未读的逻辑在后面),如果某一条消息被读了,就将对应的未读消息数据标记为已读。
除了上面说的两张表, 对于每个**会话**都有一个字段记录最新的一条消息的`id`, 每次有新消息时需要维护这个字段。
综上, 有新消息时需要依次维护3个地方:
- **会话**: 更新 最新消息 + 时间
- **消息表**: 新增了一条消息
- **未读消息表**: 有新的未读消息
- 给在线用户推新消息，包括其它自己的自己在线设备
### 已读未读
> [http://www.52im.net/thread-3054-1-1.html](http://www.52im.net/thread-3054-1-1.html)

主要策略是: 有新消息时构建全员(除了发送者)的未读消息标记为未读状态, 如果某个用户已读, 将对应的未读消息标记为已读。
这里之所以未读消息已读后不直接删除对应数据而是更新状态有以下几点原因:
- 后续查询消息已读未读状态时(细节见"查询未读消息"), 需要联合消息表和未读消息表, 这里可以设置一个状态区分, 不然后面查询时需要一些判断等额外逻辑。
- `mysql`的删除本来就是假删除, 内部就是用一个状态位来表示逻辑删除, 这里显示使用状态更新来代替删除不会影响后续查询速度。
流程如下:
- 买家发送一条信息时, 构建全员(除了发送者)的未读消息,插入未读消息表, 标记为未读
- 小明读到某条消息时发送这条消息的消息已读请求,这时将对应的未读消息标记为已读
### 撤回消息
流程图如下:
- 有撤回消息时删除撤回的那条消息内容, 更新状态为撤回状态
- 如果未读消息表里有对应的未读消息, 直接删除对应未读消息, 因为如果对方还没收到这条消息就撤回了相当于没有收到新消息。
### 查询未读消息
当用户建立websocket连接时, 需要查询自上一次断开websocket连接的未读消息, 包括有未读消息的会话, 会话里有多少未读消息, 最新一条消息是哪一条。步骤如下:
- 用户建立websocket连接时
- 分页查询会话, 按照更新时间排序, 会话结构里包括最后一条消息
- 在未读消息表里查询未读消息个数
- 当用户点进某个会话的时候, 在消息表查询该会话的所有消息, 查询消息时联合未读消息表查询消息的已读未读状态。
### 消息通知
当用户在app内(严格来说是websocket已连接未断开)时, 此用户有新消息时需要服务端推送消息通知给用户。
对于新消息, 客户端需要做以下处理:
- 将消息同步在本地
	- 新消息这种直接加数据
	- 撤回消息需要删除撤回的那一条消息内容
- 将新消息属于的聊天室顺序移到列表第一个
- 在会话列表时，增加某一条会话的未读数
- 如果当前页面就是在某个聊天室里, 且此聊天室就是消息通知的聊天室, 直接把消息标记为已读
### 上拉刷新
一次最多显示100条消息, 当用户上拉时, 优先查询本地存的消息记录(细节见"缓存方案"), 如果本地没有了, 再去服务端查询.
# 接口约定
对于客户端给服务端发送信息, 因为需要响应机制, 还是采用http, 服务端给客户端采用websocket。
## websocket
- 连接路径
```
ws/{userId}
```
因为websocket是服务端和客户端可以互发信息, 所以这里需要区分一下`客户端给服务端发消息`和`服务端给客户端发消息`。
### 客户端 -> 服务端
客户端给服务端发信息, 也就是服务端需要提供的websocket接口, 前面提到了客户端给服务端发信息采用http, 所以这里只需简单提供建立连接和断开连接的接口。
#### 信息格式
- token为用户登录时获取的token, 这里解析token沿用http那一套
- 如果token过期, 需要通知客户端
- path是具体的业务逻辑区分字段, 类似于请求路径
- body 是执行业务函数时传的参数, 类似于请求参数
```js
{
    "authorization": token, // token, 根据这个解析用户信息
    "path": "connect/hello", // 根据这个来执行不同的业务逻辑
    "body": { // 参数
        "param1": 1,
        "param2": "hello world"
    }
}
```
### 服务端 -> 客户端
服务端给客户端发信息, 也就是客户端需要提供的websocket接口。
#### 信息格式
```js
{
	"code": 0, // 状态码，出错时不为0
    "path": "group/message", // 根据这个来执行不同的业务逻辑
    "body": { // 参数
        "param1": 1,
        "param2": "hello world"
    }
}
```
- code是状态码，出错时不为0
- path是具体的业务逻辑区分字段, 类似于请求路径
- body 是执行业务函数时传的参数, 类似于请求参数
